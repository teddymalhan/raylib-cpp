cmake_minimum_required(VERSION 3.20)

#
# Project details
#

project(
  "Project"
  VERSION 0.1.0
  LANGUAGES CXX
)

#
# Set project options
#

include(cmake/StandardSettings.cmake)
include(cmake/StaticAnalyzers.cmake)
include(cmake/Utils.cmake)
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE "Debug")
endif()
message(STATUS "Started CMake for ${PROJECT_NAME} v${PROJECT_VERSION}...\n")

if (UNIX)
    add_compile_options("$<$<CONFIG:DEBUG>:-D_DEBUG>")    #this will allow to use same _DEBUG macro available in both Linux as well as Windows - MSCV environment. Easy to put Debug specific code.
endif (UNIX)


#
# Setup alternative names
#

if(${PROJECT_NAME}_USE_ALT_NAMES)
  string(TOLOWER ${PROJECT_NAME} PROJECT_NAME_LOWERCASE)
  string(TOUPPER ${PROJECT_NAME} PROJECT_NAME_UPPERCASE)
else()
  set(PROJECT_NAME_LOWERCASE ${PROJECT_NAME})
  set(PROJECT_NAME_UPPERCASE ${PROJECT_NAME})
endif()

#
# Prevent building in the source directory
#

if(PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR)
  message(FATAL_ERROR "In-source builds not allowed. Please make a new directory (called a build directory) and run CMake from there.\n")
endif()

#
# Enable package managers
#

include(cmake/Conan.cmake)
include(cmake/Vcpkg.cmake)

#
# Create library, setup header and source files
#

# Find all headers and implementation files
include(cmake/SourcesAndHeaders.cmake)

if(${PROJECT_NAME}_BUILD_EXECUTABLE)
  add_executable(${PROJECT_NAME} ${exe_sources})

  if(${PROJECT_NAME}_VERBOSE_OUTPUT)
    verbose_message("Found the following sources:")
    foreach(source IN LISTS exe_sources)
      verbose_message("* ${source}")
    endforeach()
  endif()

  if(${PROJECT_NAME}_ENABLE_UNIT_TESTING)
    add_library(${PROJECT_NAME}_LIB ${headers} ${sources})

    if(${PROJECT_NAME}_VERBOSE_OUTPUT)
      verbose_message("Found the following headers:")
      foreach(header IN LISTS headers)
        verbose_message("* ${header}")
      endforeach()
    endif()
  endif()
elseif(${PROJECT_NAME}_BUILD_HEADERS_ONLY)
  add_library(${PROJECT_NAME} INTERFACE)

  if(${PROJECT_NAME}_VERBOSE_OUTPUT)
    verbose_message("Found the following headers:")
    foreach(header IN LIST headers)
      verbose_message("* ${header}")
    endforeach()
  endif()
else()
  add_library(
    ${PROJECT_NAME}
    ${headers}
    ${sources}
  )

  if(${PROJECT_NAME}_VERBOSE_OUTPUT)
    verbose_message("Found the following sources:")
    foreach(source IN LISTS sources)
      verbose_message("* ${source}")
    endforeach()
    verbose_message("Found the following headers:")
    foreach(header IN LISTS headers)
      verbose_message("* ${header}")
    endforeach()
  endif()
endif()

set_target_properties(
  ${PROJECT_NAME}
  PROPERTIES
  ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}"
  LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}"
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin/${CMAKE_BUILD_TYPE}"
)
if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
  set_target_properties(
    ${PROJECT_NAME}_LIB
    PROPERTIES
    ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}"
    LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}"
    OUTPUT_NAME ${PROJECT_NAME}
  )
endif()

message(STATUS "Added all header and implementation files.\n")

#
# Set the project standard and warnings
#

if(${PROJECT_NAME}_BUILD_HEADERS_ONLY)
  target_compile_features(${PROJECT_NAME} INTERFACE cxx_std_23)
else()
  target_compile_features(${PROJECT_NAME} PUBLIC cxx_std_23)

  if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
    target_compile_features(${PROJECT_NAME}_LIB PUBLIC cxx_std_23)
  endif()
endif()
include(cmake/CompilerWarnings.cmake)
set_project_warnings(${PROJECT_NAME})

verbose_message("Applied compiler warnings. Using standard ${CMAKE_CXX_STANDARD}.\n")

#
# Enable Doxygen
#

include(cmake/Doxygen.cmake)

#
# Model project dependencies
#

# Detect Emscripten/Web platform
if(EMSCRIPTEN)
  set(PLATFORM_WEB TRUE)
  message(STATUS "Building for Web/WebAssembly with Emscripten")
endif()

# Raylib configuration
if(PLATFORM_WEB)
  # Web/Emscripten configuration for raylib
  # Note: raylib must be built separately for Web platform
  # You need to build raylib with: emcmake cmake -DPLATFORM=Web ...
  # and place the built libraylib.a in lib/web/
  
  # Try to find raylib built for Web
  if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/lib/web/libraylib.a)
    target_include_directories(
      ${PROJECT_NAME}
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/lib
    )
    
    target_link_libraries(
      ${PROJECT_NAME}
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/lib/web/libraylib.a
    )
    
    message(STATUS "Found raylib Web build at: ${CMAKE_CURRENT_SOURCE_DIR}/lib/web/libraylib.a")
  else()
    message(WARNING "raylib Web build not found. Please build raylib for Web platform first.")
    message(WARNING "Expected location: ${CMAKE_CURRENT_SOURCE_DIR}/lib/web/libraylib.a")
  endif()
  
  # Set Emscripten linker flags for raylib
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s USE_GLFW=3 -s ASSERTIONS=1 -s WASM=1 -s ASYNCIFY -s GL_ENABLE_GET_PROC_ADDRESS=1")
  set(CMAKE_EXECUTABLE_SUFFIX ".html")
  
  # Enable file system support for loading assets
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s ALLOW_MEMORY_GROWTH=1")
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s EXPORTED_RUNTIME_METHODS=['FS','ccall','cwrap']")
  
  # Preload assets directory (if it exists)
  if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/assets)
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --preload-file ${CMAKE_CURRENT_SOURCE_DIR}/assets@/assets")
    message(STATUS "Preloading assets directory for WASM")
  else()
    message(WARNING "Assets directory not found. Some features may not work.")
  endif()
  
elseif(APPLE)
  # Add raylib include directory
  target_include_directories(
    ${PROJECT_NAME}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib
  )
  
  # Link against raylib static library and required macOS frameworks
  target_link_libraries(
    ${PROJECT_NAME}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib/libraylib.a
    "-framework CoreVideo"
    "-framework IOKit"
    "-framework Cocoa"
    "-framework GLUT"
    "-framework OpenGL"
  )
elseif(UNIX)
  # Linux configuration (if needed in the future)
  target_include_directories(
    ${PROJECT_NAME}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib
  )
  
  target_link_libraries(
    ${PROJECT_NAME}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib/libraylib.a
    pthread
    dl
    m
  )
elseif(WIN32)
  # Windows configuration (if needed in the future)
  target_include_directories(
    ${PROJECT_NAME}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib
  )
  
  target_link_libraries(
    ${PROJECT_NAME}
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/lib/libraylib.a
    winmm
    gdi32
  )
endif()

if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
  # Also link raylib to the library target if unit testing is enabled
  if(PLATFORM_WEB)
    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/lib/web/libraylib.a)
      target_include_directories(
        ${PROJECT_NAME}_LIB
        PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/lib
      )
      
      target_link_libraries(
        ${PROJECT_NAME}_LIB
        PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/lib/web/libraylib.a
      )
    endif()
  elseif(APPLE)
    target_include_directories(
      ${PROJECT_NAME}_LIB
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/lib
    )
    
    target_link_libraries(
      ${PROJECT_NAME}_LIB
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/lib/libraylib.a
      "-framework CoreVideo"
      "-framework IOKit"
      "-framework Cocoa"
      "-framework GLUT"
      "-framework OpenGL"
    )
  endif()
endif()

# Bullet Physics configuration
if(PLATFORM_WEB)
  # Use Emscripten's built-in Bullet Physics port
  # This is automatically available when using Emscripten
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -s USE_BULLET=1")
  
  # Include paths for Bullet (Emscripten provides these)
  # The headers are available through Emscripten's system includes
  message(STATUS "Using Emscripten's built-in Bullet Physics (USE_BULLET=1)")
  
elseif(APPLE)
  # Find Bullet Physics via Homebrew
  set(BULLET_ROOT "/opt/homebrew/opt/bullet")
  if(EXISTS ${BULLET_ROOT})
    target_include_directories(
      ${PROJECT_NAME}
      PRIVATE
      ${BULLET_ROOT}/include
      ${BULLET_ROOT}/include/bullet
    )
    
    target_link_directories(
      ${PROJECT_NAME}
      PRIVATE
      ${BULLET_ROOT}/lib
    )
    
    # Link Bullet Physics libraries (static versions)
    target_link_libraries(
      ${PROJECT_NAME}
      PRIVATE
      BulletDynamics
      BulletCollision
      LinearMath
    )
    
    message(STATUS "Found Bullet Physics at: ${BULLET_ROOT}")
    
    # Also add Bullet to library target if unit testing is enabled
    if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
      target_include_directories(
        ${PROJECT_NAME}_LIB
        PRIVATE
        ${BULLET_ROOT}/include
        ${BULLET_ROOT}/include/bullet
      )
      
      target_link_directories(
        ${PROJECT_NAME}_LIB
        PRIVATE
        ${BULLET_ROOT}/lib
      )
      
      target_link_libraries(
        ${PROJECT_NAME}_LIB
        PRIVATE
        BulletDynamics
        BulletCollision
        LinearMath
      )
    endif()
  else()
    message(WARNING "Bullet Physics not found at ${BULLET_ROOT}. Please install via: brew install bullet")
  endif()
endif()

# Dear ImGui configuration
include(FetchContent)
FetchContent_Declare(
  imgui
  GIT_REPOSITORY https://github.com/ocornut/imgui.git
  GIT_TAG v1.90.5
)

# Only fetch if not already available
if(NOT imgui_POPULATED)
  FetchContent_Populate(imgui)
  
  # Create ImGui library
  add_library(imgui STATIC
    ${imgui_SOURCE_DIR}/imgui.cpp
    ${imgui_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_SOURCE_DIR}/imgui_widgets.cpp
    ${imgui_SOURCE_DIR}/imgui_demo.cpp
    ${imgui_SOURCE_DIR}/backends/imgui_impl_opengl3.cpp
  )
  
  target_include_directories(imgui PUBLIC
    ${imgui_SOURCE_DIR}
    ${imgui_SOURCE_DIR}/backends
  )
  
  # Set C++ standard
  target_compile_features(imgui PUBLIC cxx_std_11)
  
  # Platform-specific settings
  if(APPLE)
    target_compile_definitions(imgui PRIVATE __APPLE__)
  endif()
  
  message(STATUS "ImGui fetched and configured")
endif()

# Link ImGui to project
target_link_libraries(${PROJECT_NAME} PRIVATE imgui)

if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
  target_link_libraries(${PROJECT_NAME}_LIB PRIVATE imgui)
endif()

# EnTT ECS configuration
if(PLATFORM_WEB)
  # EnTT is header-only, so we just need to find it
  # For Web builds, you can either:
  # 1. Use a header-only version (copy headers to include/)
  # 2. Use vcpkg with wasm32-emscripten triplet
  # 3. Include EnTT headers directly
  
  # Try to find EnTT in standard locations or as a submodule
  if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/third_party/entt/include/entt/entt.hpp)
    target_include_directories(
      ${PROJECT_NAME}
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/third_party/entt/include
    )
    message(STATUS "Found EnTT at: ${CMAKE_CURRENT_SOURCE_DIR}/third_party/entt/include")
  elseif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/lib/entt/include/entt/entt.hpp)
    target_include_directories(
      ${PROJECT_NAME}
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/lib/entt/include
    )
    message(STATUS "Found EnTT at: ${CMAKE_CURRENT_SOURCE_DIR}/lib/entt/include")
  else()
    # Try to find via pkg-config (may work if installed)
    find_package(PkgConfig QUIET)
    if(PkgConfig_FOUND)
      pkg_check_modules(ENTT QUIET entt)
      if(ENTT_FOUND)
        target_include_directories(${PROJECT_NAME} PRIVATE ${ENTT_INCLUDE_DIRS})
        message(STATUS "Found EnTT via pkg-config")
      else()
        message(WARNING "EnTT not found. Please ensure EnTT headers are available.")
      endif()
    else()
      message(WARNING "EnTT not found. Please ensure EnTT headers are available.")
    endif()
  endif()
  
elseif(APPLE)
  # Find EnTT via Homebrew
  set(ENTT_ROOT "/opt/homebrew/opt/entt")
  if(EXISTS ${ENTT_ROOT})
    target_include_directories(
      ${PROJECT_NAME}
      PRIVATE
      ${ENTT_ROOT}/include
    )
    
    message(STATUS "Found EnTT at: ${ENTT_ROOT}")
    
    # Also add EnTT to library target if unit testing is enabled
    if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
      target_include_directories(
        ${PROJECT_NAME}_LIB
        PRIVATE
        ${ENTT_ROOT}/include
      )
    endif()
  else()
    message(WARNING "EnTT not found at ${ENTT_ROOT}. Please install via: brew install entt")
  endif()
elseif(UNIX)
  # Linux: try to find EnTT via pkg-config or standard paths
  find_package(PkgConfig QUIET)
  if(PkgConfig_FOUND)
    pkg_check_modules(ENTT QUIET entt)
    if(ENTT_FOUND)
      target_include_directories(${PROJECT_NAME} PRIVATE ${ENTT_INCLUDE_DIRS})
      message(STATUS "Found EnTT via pkg-config")
    endif()
  endif()
endif()

# For Windows, it is necessary to link with the MultiThreaded library.
# Depending on how the rest of the project's dependencies are linked, it might be necessary
# to change the line to statically link with the library.
#
# This is done as follows:
#
# set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")
#
# On Linux and Mac this variable is ignored. If any issues rise from it, try commenting it out
# and letting CMake decide how to link with it.
set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL")

verbose_message("Successfully added all dependencies and linked against them.")

#
# Set the build/user include directories
#

# Allow usage of header files in the `src` directory, but only for utilities
if(${PROJECT_NAME}_BUILD_HEADERS_ONLY)
  target_include_directories(
    ${PROJECT_NAME}
    INTERFACE
    $<INSTALL_INTERFACE:include>
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  )
else()
  target_include_directories(
    ${PROJECT_NAME}
    PUBLIC
    $<INSTALL_INTERFACE:include>
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
  )
  if(${PROJECT_NAME}_BUILD_EXECUTABLE AND ${PROJECT_NAME}_ENABLE_UNIT_TESTING)
    target_include_directories(
      ${PROJECT_NAME}_LIB
      PUBLIC
      $<INSTALL_INTERFACE:include>
      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
      PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/src
    )
  endif()
endif()

message(STATUS "Finished setting up include directories.")

#
# Provide alias to library for
#

if(${PROJECT_NAME}_BUILD_EXECUTABLE)
  add_executable(${PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
else()
  add_library(${PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
endif()

verbose_message("Project is now aliased as ${PROJECT_NAME}::${PROJECT_NAME}.\n")

#
# Format the project using the `clang-format` target (i.e: cmake --build build --target clang-format)
#

add_clang_format_target()

#
# Install library for easy downstream inclusion
#

include(GNUInstallDirs)
install(
  TARGETS
  ${PROJECT_NAME}
  EXPORT
  ${PROJECT_NAME}Targets
  LIBRARY DESTINATION
  ${CMAKE_INSTALL_LIBDIR}
  RUNTIME DESTINATION
  ${CMAKE_INSTALL_BINDIR}
  ARCHIVE DESTINATION
  ${CMAKE_INSTALL_LIBDIR}
  INCLUDES DESTINATION
  include
  PUBLIC_HEADER DESTINATION
  include
)

install(
  EXPORT
  ${PROJECT_NAME}Targets
  FILE
  ${PROJECT_NAME}Targets.cmake
  NAMESPACE
  ${PROJECT_NAME}::
  DESTINATION
  ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
)

#
# Add version header
#

configure_file(
  ${CMAKE_CURRENT_LIST_DIR}/cmake/version.hpp.in
  include/${PROJECT_NAME_LOWERCASE}/version.hpp
  @ONLY
)

install(
  FILES
  ${CMAKE_CURRENT_BINARY_DIR}/include/${PROJECT_NAME_LOWERCASE}/version.hpp
  DESTINATION
  include/${PROJECT_NAME_LOWERCASE}
)

#
# Install the `include` directory
#

install(
  DIRECTORY
  include/${PROJECT_NAME_LOWERCASE}
  DESTINATION
  include
)

verbose_message("Install targets successfully built. Install with `cmake --build <build_directory> --target install --config <build_config>`.")

#
# Quick `ConfigVersion.cmake` creation
#

include(CMakePackageConfigHelpers)
write_basic_package_version_file(
  ${PROJECT_NAME}ConfigVersion.cmake
  VERSION
  ${PROJECT_VERSION}
  COMPATIBILITY
  SameMajorVersion
)

configure_package_config_file(
  ${CMAKE_CURRENT_LIST_DIR}/cmake/${PROJECT_NAME}Config.cmake.in
  ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
  INSTALL_DESTINATION
  ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
)

install(
  FILES
  ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake
  ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}ConfigVersion.cmake
  DESTINATION
  ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
)

#
# Generate export header if specified
#

if(${PROJECT_NAME}_GENERATE_EXPORT_HEADER)
  include(GenerateExportHeader)
  generate_export_header(${PROJECT_NAME})
  install(
    FILES
    ${PROJECT_BINARY_DIR}/${PROJECT_NAME_LOWERCASE}_export.h
    DESTINATION
    include
  )

  message(STATUS "Generated the export header `${PROJECT_NAME_LOWERCASE}_export.h` and installed it.")
endif()

message(STATUS "Finished building requirements for installing the package.\n")

#
# Unit testing setup
#

if(${PROJECT_NAME}_ENABLE_UNIT_TESTING)
  enable_testing()
  message(STATUS "Build unit tests for the project. Tests should always be found in the test folder\n")
  add_subdirectory(test)
endif()
